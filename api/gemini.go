package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"time"
)

type GeminiRequest struct {
	Prompt      string `json:"prompt"`
	Scenario    string `json:"scenario"`
	Tone        string `json:"tone"`
	TemplateFor string `json:"template_for"` // "phishing" or "awareness"
}

type GeminiAPIRequest struct {
	Contents []struct {
		Parts []struct {
			Text string `json:"text"`
		} `json:"parts"`
	} `json:"contents"`
}

type GeminiAPIResponse struct {
	Candidates []struct {
		Content struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		} `json:"content"`
	} `json:"candidates"`
}

func GenerateTemplateWithGemini(w http.ResponseWriter, r *http.Request) {
	var req GeminiRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, "Invalid request", http.StatusBadRequest)
		return
	}

	// Get API key from query parameter (user will provide it)
	apiKey := r.URL.Query().Get("api_key")
	if apiKey == "" {
		respondError(w, "Gemini API key is required. Please provide it as ?api_key=YOUR_KEY", http.StatusBadRequest)
		return
	}

	// Build the prompt based on template type
	var fullPrompt string
	if req.TemplateFor == "phishing" {
		fullPrompt = fmt.Sprintf(`You are a cybersecurity professional creating a phishing simulation template for security awareness training.

Scenario: %s
Tone: %s
Additional requirements: %s

Please generate a realistic phishing email template with the following structure:
1. A compelling subject line
2. HTML email body that looks professional and convincing
3. A call-to-action that would lead to a landing page

The email should use common phishing tactics like urgency, authority, or curiosity.
Include placeholders for: {{.FirstName}}, {{.LastName}}, {{.Email}}, {{.TrackingURL}}

Respond in JSON format:
{
  "subject": "...",
  "html": "...",
  "text": "..."
}`, req.Scenario, req.Tone, req.Prompt)
	} else {
		fullPrompt = fmt.Sprintf(`You are creating educational content for cybersecurity awareness training.

Topic: %s
Style: %s
Additional notes: %s

Please generate an educational MCQ (Multiple Choice Question) for security awareness training.
The question should test understanding of the topic and include 4 answer options with only one correct answer.

Respond in JSON format:
{
  "question_text": "...",
  "points": 1,
  "answer_options": [
    {"option_text": "...", "is_correct": true},
    {"option_text": "...", "is_correct": false},
    {"option_text": "...", "is_correct": false},
    {"option_text": "...", "is_correct": false}
  ]
}`, req.Scenario, req.Tone, req.Prompt)
	}

	// Call Gemini API
	geminiReq := GeminiAPIRequest{
		Contents: []struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		}{
			{
				Parts: []struct {
					Text string `json:"text"`
				}{
					{Text: fullPrompt},
				},
			},
		},
	}

	jsonData, _ := json.Marshal(geminiReq)

	geminiURL := fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=%s", apiKey)

	resp, err := http.Post(geminiURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		respondError(w, "Failed to call Gemini API: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		respondError(w, "Failed to read Gemini response", http.StatusInternalServerError)
		return
	}

	if resp.StatusCode != http.StatusOK {
		respondError(w, fmt.Sprintf("Gemini API error: %s", string(body)), http.StatusBadGateway)
		return
	}

	var geminiResp GeminiAPIResponse
	if err := json.Unmarshal(body, &geminiResp); err != nil {
		respondError(w, "Failed to parse Gemini response", http.StatusInternalServerError)
		return
	}

	if len(geminiResp.Candidates) == 0 || len(geminiResp.Candidates[0].Content.Parts) == 0 {
		respondError(w, "No content generated by Gemini", http.StatusInternalServerError)
		return
	}

	generatedText := geminiResp.Candidates[0].Content.Parts[0].Text

	// Try to parse the JSON response from Gemini
	// Clean up the response (remove markdown code blocks if present)
	cleanedText := generatedText
	if bytes.Contains([]byte(generatedText), []byte("```json")) {
		start := bytes.Index([]byte(generatedText), []byte("```json"))
		end := bytes.LastIndex([]byte(generatedText), []byte("```"))
		if start != -1 && end != -1 && end > start {
			cleanedText = generatedText[start+7 : end]
		}
	} else if bytes.Contains([]byte(generatedText), []byte("```")) {
		start := bytes.Index([]byte(generatedText), []byte("```"))
		end := bytes.LastIndex([]byte(generatedText), []byte("```"))
		if start != -1 && end != -1 && end > start {
			cleanedText = generatedText[start+3 : end]
		}
	}

	respondJSON(w, map[string]interface{}{
		"success":        true,
		"generated_text": cleanedText,
		"raw_response":   generatedText,
	})
}

// GenerateRandomPhishingTemplate generates a random phishing email template with one click
func GenerateRandomPhishingTemplate(w http.ResponseWriter, r *http.Request) {
	// Get API key from query parameter
	apiKey := r.URL.Query().Get("api_key")
	if apiKey == "" {
		respondError(w, "Gemini API key is required. Please provide it as ?api_key=YOUR_KEY", http.StatusBadRequest)
		return
	}

	// Random scenarios for phishing templates
	scenarios := []string{
		"Urgent password reset required",
		"Package delivery notification",
		"Account suspended - verify your identity",
		"You've won a prize - claim now",
		"Important security alert from IT department",
		"Invoice payment overdue",
		"Meeting invitation from CEO",
		"Verify your payment information",
		"Tax refund notification",
		"Social media account locked",
		"Banking security update required",
		"Cloud storage quota exceeded",
		"Employee benefits enrollment",
		"Network maintenance notification",
		"Customer complaint requires attention",
	}

	// Pick a random scenario (simple random based on time)
	rand.Seed(time.Now().UnixNano())
	scenario := scenarios[rand.Intn(len(scenarios))]

	fullPrompt := fmt.Sprintf(`You are a cybersecurity professional creating a phishing simulation template for security awareness training.

Scenario: %s
Tone: Professional and convincing

Please generate a realistic phishing email template with the following structure:
1. A compelling subject line
2. HTML email body that looks professional and convincing
3. A call-to-action that would lead to a landing page

The email should use common phishing tactics like urgency, authority, or curiosity.
Include placeholders for: {{.FirstName}}, {{.LastName}}, {{.Email}}, {{.TrackingURL}}

Respond in JSON format:
{
  "subject": "...",
  "html": "...",
  "text": "..."
}`, scenario)

	// Call Gemini API
	geminiReq := GeminiAPIRequest{
		Contents: []struct {
			Parts []struct {
				Text string `json:"text"`
			} `json:"parts"`
		}{
			{
				Parts: []struct {
					Text string `json:"text"`
				}{
					{Text: fullPrompt},
				},
			},
		},
	}

	jsonData, _ := json.Marshal(geminiReq)
	geminiURL := fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=%s", apiKey)

	resp, err := http.Post(geminiURL, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		respondError(w, "Failed to call Gemini API: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		respondError(w, "Failed to read Gemini response", http.StatusInternalServerError)
		return
	}

	if resp.StatusCode != http.StatusOK {
		respondError(w, fmt.Sprintf("Gemini API error: %s", string(body)), http.StatusBadGateway)
		return
	}

	var geminiResp GeminiAPIResponse
	if err := json.Unmarshal(body, &geminiResp); err != nil {
		respondError(w, "Failed to parse Gemini response", http.StatusInternalServerError)
		return
	}

	if len(geminiResp.Candidates) == 0 || len(geminiResp.Candidates[0].Content.Parts) == 0 {
		respondError(w, "No content generated by Gemini", http.StatusInternalServerError)
		return
	}

	generatedText := geminiResp.Candidates[0].Content.Parts[0].Text

	// Clean up the response
	cleanedText := generatedText
	if bytes.Contains([]byte(generatedText), []byte("```json")) {
		start := bytes.Index([]byte(generatedText), []byte("```json"))
		end := bytes.LastIndex([]byte(generatedText), []byte("```"))
		if start != -1 && end != -1 && end > start {
			cleanedText = generatedText[start+7 : end]
		}
	} else if bytes.Contains([]byte(generatedText), []byte("```")) {
		start := bytes.Index([]byte(generatedText), []byte("```"))
		end := bytes.LastIndex([]byte(generatedText), []byte("```"))
		if start != -1 && end != -1 && end > start {
			cleanedText = generatedText[start+3 : end]
		}
	}

	respondJSON(w, map[string]interface{}{
		"success":        true,
		"scenario":       scenario,
		"generated_text": cleanedText,
		"raw_response":   generatedText,
	})
}
